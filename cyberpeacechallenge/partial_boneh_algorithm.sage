import hashlib

def xor(xs, ys):
    return "".join(chr(ord(x).__xor__(ord(y))) for x, y in zip(xs, ys))

def to_bytes(n, length, endianess='big'):
    h = '%x' % n
    s = ('0'*(len(h) % 2) + h).zfill(length*2).decode('hex')
    return s if endianess == 'big' else s[::-1]

#Encodes using canonical representation: ax+b is b||a
def canonic(gID):
    poly = gID.polynomial().coefficients(sparse = False)
    return to_bytes(poly[0], 64) + to_bytes(poly[1],64)

#Precomputes some values for the computation of the twisted Weil pairing. 
def computeTwistedWeilParams(p):
    Fp = Integers(p)
    Pol.<btemp> = PolynomialRing(Fp)
    F2.<a> = GF(p^2, modulus=btemp^2+1)
    E2 = EllipticCurve(F2,[0,1])
    xtemp1 = -Fp(1)/Fp(2)
    xtemp2 = sqrt(xtemp1^2+xtemp1+1)
    z = xtemp1+xtemp2*a 
    return (E2, z, p)

#Computes the "twisted" Weil pairing between P1 and P2. 
#You need to pass as an additionnal argument twistedWeilParams that are generated by the method computeTwistedWeilParams(p) during key generation
def twistedWeil(P1,P2, twistedWeilParams):
    (E2, z, p) = twistedWeilParams 
    P1E2 = E2(P1.xy()) 
    P2E2 = E2(P2.xy()) 
    qx,qy = P1E2.xy() 
    P1twisted =E2(qx*z,qy) 
    return P1twisted.weil_pairing(P2E2,p+1) 


def H2(input):
    return hashlib.sha512(canonic(input)).digest()

#Hash id to point on E
def HTP(E,p,q,id):
    h = int(hashlib.sha512(str(id) + "0").hexdigest()+hashlib.sha512(str(id) + "1").hexdigest(),16) 
    Fp = GF(p)
    y = Fp(h) 
    x = (y^2-1)^((2*p-1)/3)
    Q_1 = E(x,y) 
    a_1 = (p+1)//q
    Q = a_1 * Q_1 
    return Q